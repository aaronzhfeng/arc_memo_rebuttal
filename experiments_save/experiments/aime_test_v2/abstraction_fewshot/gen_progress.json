[["```yaml\n- situation: \"When a process involves moving between a sequence of states (such as positions, pads, or numbers) with probabilistic transitions, and you are asked for the probability of reaching a particular state before another.\"\n  suggestion: \"Define a function representing the probability of success from each state, set up recurrence relations based on the transition probabilities, and solve these equations recursively, working backwards from known boundary conditions.\"\n- situation: \"When the problem involves random walks or Markov processes with absorbing states (states that, once reached, cannot be left), and you need the probability of being absorbed in one state versus another.\"\n  suggestion: \"Identify the absorbing states, assign their probabilities (typically 0 or 1), and use these as boundary conditions to recursively compute the probabilities for the other states.\"\n- situation: \"When the final answer asks for a sum or combination of numerator and denominator after expressing a probability as a reduced fraction.\"\n  suggestion: \"After computing the required probability as a fraction, ensure it is in lowest terms, and then perform the requested operation (such as summing numerator and denominator) to obtain the final answer.\"\n```"],["```yaml\n- situation: \"When multiple equations involve overlapping variables (e.g., abc = N, cde = M) and you are asked to count the number of integer solutions.\"\n  suggestion: \"Look for variables that appear in more than one equation and see if their value is forced by divisibility constraints, such as by considering the greatest common divisor (gcd) of the constants involved.\"\n- situation: \"When a variable is forced to be 1 because it must divide two coprime numbers (or a prime and a non-multiple), and this variable appears in multiple equations.\"\n  suggestion: \"Set the shared variable to 1 and reduce the problem to counting ordered factor pairs for the remaining variables in each equation.\"\n- situation: \"When counting the number of ordered tuples (a, b, ...) such that the product of some variables equals a fixed integer.\"\n  suggestion: \"Count the number of ordered factor pairs (or tuples) for the given product, using the number of divisors and considering order if required.\"\n- situation: \"When a variable must be a divisor of a given number, and only certain values are possible based on previous constraints.\"\n  suggestion: \"Check which candidate values for the variable are compatible with all constraints, and eliminate those that do not divide the required number.\"\n- situation: \"When the problem involves multiple stages of variable assignment, each reducing the possibilities for the next.\"\n  suggestion: \"Proceed step by step, at each stage using the constraints to narrow down the possible values, and multiply the counts of valid choices at each stage to get the total number of solutions.\"\n```"],["```yaml\n- situation: \"When a problem involves the product of random variables (such as dice rolls) and asks about divisibility or properties related to the exponents of prime factors.\"\n  suggestion: \"Encode each outcome by the parity (modulo 2) or residue class of the relevant exponents in the prime factorization, reducing the problem to a question about sums in a finite abelian group (such as F₂ⁿ for n primes).\"\n\n- situation: \"When you need the probability that the sum (modulo 2 or another modulus) of several independent random vectors is zero, and the distribution is not uniform.\"\n  suggestion: \"Use the discrete Fourier (character sum) method: express the probability as a sum over group characters, where each term is the expected value of the character raised to the number of variables, and evaluate these sums to get the answer.\"\n\n- situation: \"When the problem involves symmetries or group structure (such as sums in F₂ⁿ) and the random variables are independent but not identically distributed.\"\n  suggestion: \"Identify the group structure and use linear algebra or character theory to simplify the computation, leveraging independence to factor expectations and reduce the problem to manageable algebraic expressions.\"\n```"],["```yaml\n- situation: \"When the problem involves selecting non-overlapping pairs or groups from a cyclic or circular arrangement (such as seats around a table), especially where adjacency or parity (even/odd) constraints are present.\"\n  suggestion: \"Model the selection as a matching problem on a cycle graph, and use known combinatorial formulas for matchings in cycles or paths to count the possibilities efficiently.\"\n- situation: \"When you have to assign distinct labels or roles to a set of chosen objects (such as people to seats) after a combinatorial selection step.\"\n  suggestion: \"Separate the counting into two stages: first count the number of ways to choose the objects/groups (e.g., matchings), then multiply by the number of ways to assign the labels (e.g., permutations), ensuring that each stage respects the problem's constraints.\"\n- situation: \"When the final answer requires a value modulo some number (e.g., 'modulo 1000'), especially after a large product or sum.\"\n  suggestion: \"Perform the modulo operation at the end of the calculation, but consider reducing intermediate results modulo the given number if the numbers become unwieldy, to simplify computation and avoid errors.\"\n```"],["```yaml\n- situation: \"When a problem involves logarithms with unknown bases or arguments, and variables appear both as exponents and as arguments of logarithms (e.g., log_b x and log_b(log_b x)).\"\n  suggestion: \"Introduce a substitution for the logarithm (such as L = log_b x) to simplify the relationships and rewrite all equations in terms of this new variable. This can reveal hidden algebraic relationships and make the system more tractable.\"\n- situation: \"When you have multiple equations involving logarithms and exponents, and one equation can be solved for a variable in terms of another.\"\n  suggestion: \"Use one equation to express a variable in terms of another, then substitute into the other equation(s) to reduce the number of variables and solve step by step.\"\n- situation: \"When a logarithmic equation leads to an expression like log_b(L) = L/k for some constant k.\"\n  suggestion: \"Exponentiate both sides to get L = b^{L/k}, which can sometimes be solved by relating powers and logarithms, or by substituting back into other equations.\"\n- situation: \"When you arrive at a value for a logarithm (e.g., log_b x = L), and need to find the base b.\"\n  suggestion: \"Rewrite the logarithmic equation in exponential form (e.g., x = b^L or L = b^{L/k}), and use any other relationships or known values to solve for b.\"\n```"],["```yaml\n- situation: \"When a problem involves evaluating a polynomial at roots of unity, especially with large exponents or periodicity in the exponents.\"\n  suggestion: \"Reduce the exponents modulo the order of the root of unity to simplify the expression, since powers repeat cyclically. Substitute the root of unity and its powers as complex numbers if needed to equate real and imaginary parts.\"\n- situation: \"When you have a complex equation resulting from evaluating a polynomial at a root of unity and are given the value as a complex number.\"\n  suggestion: \"Equate real and imaginary parts to form a system of linear equations in the unknown coefficients, then solve for the coefficients.\"\n- situation: \"When the problem asks for the value of a polynomial at 1 (i.e., f(1)) after determining its coefficients, and the answer is required modulo some number.\"\n  suggestion: \"Sum the solved coefficients to compute f(1), then reduce the result modulo the specified modulus to obtain the final answer.\"\n- situation: \"When the problem involves unknown coefficients with constraints (such as upper/lower bounds) and you obtain a solution that must be checked against these constraints.\"\n  suggestion: \"Verify that the solution for the coefficients satisfies all given bounds or conditions before proceeding to the final calculation.\"\n```"],["```yaml\n- situation: \"When a problem asks for numbers with a specific number of divisors (i.e., a fixed value of the divisor function τ(n)), especially for moderately large τ(n).\"\n  suggestion: \"List all possible combinations of exponents in the prime factorization whose incremented product equals the target divisor count. Systematically enumerate all tuples (a+1)(b+1)... = target, then reconstruct possible n from these patterns.\"\n- situation: \"When additional divisibility constraints are imposed (e.g., n must be divisible by certain primes or powers, such as 4 or 20).\"\n  suggestion: \"For each exponent pattern, ensure that the required primes appear with sufficient exponent in the factorization. Discard patterns that cannot accommodate the divisibility requirements.\"\n- situation: \"When the problem restricts n to be less than a certain bound.\"\n  suggestion: \"After generating candidate numbers from valid exponent patterns and divisibility constraints, check each candidate against the upper bound and eliminate those that are too large.\"\n- situation: \"When the problem asks for the sum or average of all numbers satisfying certain arithmetic or divisor properties.\"\n  suggestion: \"Once all valid numbers are enumerated, compute the required aggregate (sum, average, etc.) directly, ensuring no duplicates and that all constraints are satisfied.\"\n```"],["```yaml\n- situation: \"When a function (such as trigonometric, exponential, or modular) is repeatedly applied to a variable (e.g., $2^n\\theta$), and the puzzle asks about the sign, value, or behavior as $n$ varies.\"\n  suggestion: \"Analyze the periodicity and residue classes of the argument modulo the function's period. Seek patterns in how the argument cycles through intervals where the function's behavior changes (such as sign changes for tangent), and relate this to modular arithmetic.\"\n\n- situation: \"When a desired pattern in function values (e.g., alternating signs, periodicity every $k$ steps) is specified for all $n$, and the function's argument grows exponentially or doubles each time.\"\n  suggestion: \"Set up recurrence or congruence relations for the argument under repeated application (e.g., $A_{n+1} = 2A_n \\pmod{\\text{period}}$), and solve for parameters (like $\\theta$) that force the pattern to repeat with the required period.\"\n\n- situation: \"When a solution involves checking several possible parameter values due to modular constraints (e.g., $\\theta = \\frac{180k}{7}$ for integer $k$), and only some satisfy all interval or sign requirements.\"\n  suggestion: \"Systematically test all candidate parameter values within the allowed range, verifying that each step of the pattern matches the specified behavior, and eliminate those that fail at any step.\"\n\n- situation: \"When the problem involves trigonometric functions and modular arithmetic, especially with periodicity or symmetry.\"\n  suggestion: \"Recall the fundamental periods and sign intervals of the trigonometric functions, and use modular arithmetic to track how the argument moves through these intervals under iteration.\"\n```"]]